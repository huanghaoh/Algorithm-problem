## 什么是二分查找

二分查找是一种常用的查找方法，每次都将查找范围减少一半，可以将时间复杂度减少到O(logn)。使用二分查找的前提是在一个有序的数组中，并且没有重复元素。二分查找的查找范围有两种写法。

![image-20220213205424201](https://gitee.com/huanghaoh/imgbed/raw/master/img/202202132054259.png)

定义一个左指针left，右指针right，中间指针middle=(left+right)/2（可以写成left+(right-left)/2，防止数较大时溢出）。将要查找的值target与middle所指的值作比较，如果相等，查找完毕；如果target大，left向右移动；如果target小，right向左移动。

## 写法一

~~~C++
int search(int* nums, int numsSize, int target){
    int left = 0;
    int right = numsSize - 1;
    while(left <= right){ //不同点1
        int middle = left + (right - left) / 2;
        if(target > nums[middle])
            left = middle + 1;
        else if(target < nums[middle])
            right = middle - 1; //不同点2
        else
            return middle;
    }
    return -1;
}
~~~

## 写法二

~~~C++
int search(int nums[], int numsSize, int target){
    int left = 0;
    int right = numsSize;
    while(left < right){ //不同点1
        int middle = left + (right - left) / 2;
        if(target > nums[middle])
            left = middle + 1;
        else
            right = middle; //不同点2
    }
    return nums[left] == target ? left : -1;
}
~~~

## 总结

❓两种写法判定结束条件为什么不一样？

第一种写法当搜索区间收缩到left等于right时，由于是闭区间，left=right的这个值还没有被搜索，所以不能结束。而第二种写法是开区间，left=right这个值不在区间内，所以不用搜索。即right是数组下标时，用<=；是数组长度时，用<。

❓既然第一种写法可以解决问题，那么为什么要有第二种写法呢？

如果是标准的有序数组，没有重复元素，使用第一种写法即可。第二种写法主要是为了解决数组中有重复元素，查找左边界的问题。当nums[middle]第一次等于target时，无法确定middle是左边界，所以收缩右边界继续向左搜索，直到结束循环。同样的，如果是查找右边界的问题，只需要更改判定条件，向右收缩即可。

