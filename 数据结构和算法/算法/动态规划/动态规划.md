## 什么是动态规划

动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。通俗来说就是把给定的原问题不断拆分成子问题，直到子问题可以直接求解；然后把子问题的答案保存起来，以减少重复计算，再根据子问题递推求出原问题的解。

## 动态规划的适用条件

1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

4. 动态规划通常应用于解决计数问题、求最大最小值问题和存在性的问题。

## 动态规划的求解步骤

这里以[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)为例说明，假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

   ### 确定状态

我们可以选择从后往前推，最终的目的是爬完n阶楼梯，那么往前推一步，我们在n-1阶或n-2阶楼梯上，因为一次只能爬1阶或2阶楼梯；再往前推，如果我们在n-1阶楼梯上，那么此时在n-2或n-3阶楼梯上；如果我们在n-2阶楼梯上，那么此时在n-3或n-4阶楼梯上；继续下去我们就得到了一棵递归树。

![image-20220315193924383](http://reujbch3s.hn-bkt.clouddn.com/img/202203151939499.png)

我们也可以从前往后推，爬到第1阶楼梯时，有$f(1)=1$种方法；爬到第二阶楼梯时，有$f(2)=2$种方法；爬到第三阶楼梯时有$f(3)=f(2)+f(1)=3$种方法，继续推下去就可以得到状态。

### 确定状态转移方程

我们定义一个数组dp记录子问题的解，以减少重复计算。根据第一步的状态可以得到状态转移方程$dp[n]=dp[n-1]+dp[n-2]$。

### 确定初始条件和边界情况

初始条件就是最小子问题的解，那么这道题的初始条件就是$dp[1]=1,dp[2]=2$。

边界情况通常是递推不到或造成数组越界的值。例如当我们输入为1时，dp数组的长度为2，再初始化dp[2]就会造成数组越界；所以需要我们额外处理边界情况，$if(n == 1)\ return \ 1$。

### 代码实现

~~~c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1)
            return 1;
        int dp[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
~~~

### 代码优化

如果状态转移时，仅仅用到当前状态的前几个状态，而不是随机使用状态，那么使用dp数组会造成空间的浪费，这时候我们可以维护几个变量代替数组以减少开支。

~~~c++
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)
            return n;
        int dp1 = 1, dp2 = 2, sum = 0;
        for(int i = 3; i <= n; i++){
            sum = dp1 + dp2;
            dp1 = dp2;
            dp2 = sum;
        }
        return sum;
    }
};
~~~

## 动态规划框架

~~~c++
dp[0][0][...] = 边界值
for(状态1 ：所有状态1的值){
    for(状态2 ：所有状态2的值){
        for(...){
          //状态转移方程
          dp[状态1][状态2][...] = 求最值
        }
    }
}
~~~

